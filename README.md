在这个系统中，生产者负责生产爬取的目标URL，将其塞到缓冲区中。消费者则负责爬取的各个子进程，从缓冲区获取生产者生产的URL，然后下一步操作。这个模型本质上一个消息队列，在这里选择Redis来实现。（Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。）

生产者的实现：（会定义以下事件）
begin：开始运行时触发。
pause：如果消费者的速度跟不上生产者的速度，需要引入暂停事件，通常使用内存来做缓冲需要考虑这一点，关于暂停的一个细节是要保存暂停时的状态，以便恢复时能继续暂停前的状态进行处理。
resume：从暂停中恢复，需要读取保存的暂停前的状态。
其中需要一个函数获取缓冲区的长度，然后定下一个阈值，当缓冲区长度大于该阈值的时候让生产者停下来，虽然消费者是多进程运行，但网络IO耗时毕竟远大于生产耗时，所以阈值的设置要大一些。
借助第三方模块bluebird，可以将redis的API转换成promise形式。
